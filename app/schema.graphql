type Article implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: UUID!
  authorRowId: UUID!
  title: String!
  content: String
  createdAt: CreatedTimestamp!
  updatedAt: UpdatedTimestamp!

  # Reads a single `User` that is related to this `Article`.
  author: User!
}

# A condition to be used against `Article` object types. All fields are tested for equality and combined with a logical ‘and.’
input ArticleCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `authorRowId` field.
  authorRowId: UUID

  # Checks for equality with the object’s `title` field.
  title: String

  # Checks for equality with the object’s `content` field.
  content: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: CreatedTimestamp

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: UpdatedTimestamp
}

# A connection to a list of `Article` values.
type ArticlesConnection {
  # A list of `Article` objects.
  nodes: [Article!]!

  # A list of edges which contains the `Article` and cursor to aid in pagination.
  edges: [ArticlesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Article` you could get from the connection.
  totalCount: Int
}

# A `Article` edge in the connection.
type ArticlesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Article` at the end of the edge.
  node: Article!
}

# Methods to use when ordering `Article`.
enum ArticlesOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  AUTHOR_ROW_ID_ASC
  AUTHOR_ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  CONTENT_ASC
  CONTENT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# All input for the `authenticate` mutation.
input AuthenticateInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!
  password: String!
}

# The output of our `authenticate` mutation.
type AuthenticatePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  jwtToken: JwtToken

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createArticle` mutation.
input CreateArticleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  title: String!
  content: String
}

# The output of our `createArticle` mutation.
type CreateArticlePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  article: Article

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Article`.
  author: User!

  # An edge for our `Article`. May be used by Relay 1.
  articleEdge(
    # The method to use when ordering `Article`.
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

# UTC timestamp representing the time at which a node is created.
scalar CreatedTimestamp

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# All input for the `deleteArticle` mutation.
input DeleteArticleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# The output of our `deleteArticle` mutation.
type DeleteArticlePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  article: Article

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Article`.
  author: User!

  # An edge for our `Article`. May be used by Relay 1.
  articleEdge(
    # The method to use when ordering `Article`.
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

# E-Mail address with simple plausability check.
scalar EmailAddress

# A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
# which securely represents claims between two parties.
scalar JwtToken

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  # Authenticates a `User`.
  authenticate(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: AuthenticateInput!
  ): AuthenticatePayload

  # Creates an `Article` with the `viewer` as the author.
  createArticle(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateArticleInput!
  ): CreateArticlePayload

  # Deletes an `Article` with the `rowId`.
  deleteArticle(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteArticleInput!
  ): DeleteArticlePayload

  # Creates a new `User`.
  register(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: RegisterInput!
  ): RegisterPayload

  # Updates an `Article` with the `rowId`.
  updateArticle(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateArticleInput!
  ): UpdateArticlePayload
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  id: ID!

  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    id: ID!
  ): Node

  # Reads and enables pagination through a set of `Article`.
  allArticles(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Article`.
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ArticleCondition
  ): ArticlesConnection

  # Reads and enables pagination through a set of `User`.
  allUsers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `User`.
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
  ): UsersConnection
  articleByRowId(rowId: UUID!): Article
  articleByTitle(title: String!): Article
  userByRowId(rowId: UUID!): User
  userByEmail(email: EmailAddress!): User

  # Currently authenticated `User`.
  viewer: User

  # Reads a single `Article` using its globally unique `ID`.
  article(
    # The globally unique `ID` to be used in selecting a single `Article`.
    id: ID!
  ): Article

  # Reads a single `User` using its globally unique `ID`.
  user(
    # The globally unique `ID` to be used in selecting a single `User`.
    id: ID!
  ): User
}

# All input for the `register` mutation.
input RegisterInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

# The output of our `register` mutation.
type RegisterPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  jwtToken: JwtToken

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateArticle` mutation.
input UpdateArticleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
  title: String!
  content: String
}

# The output of our `updateArticle` mutation.
type UpdateArticlePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  article: Article

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Article`.
  author: User!

  # An edge for our `Article`. May be used by Relay 1.
  articleEdge(
    # The method to use when ordering `Article`.
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

# UTC timestamp representing the time at which a node is updated.
scalar UpdatedTimestamp

type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: UUID!
  email: EmailAddress!
  firstName: String!
  lastName: String!
  createdAt: CreatedTimestamp!
  updatedAt: UpdatedTimestamp!

  # Reads and enables pagination through a set of `Article`.
  articles(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Article`.
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]

    # A condition to be used in determining which values should be returned by the collection.
    condition: ArticleCondition
  ): ArticlesConnection!

  # Combined first and last name of the `User`.
  fullName: String
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `email` field.
  email: EmailAddress

  # Checks for equality with the object’s `firstName` field.
  firstName: String

  # Checks for equality with the object’s `lastName` field.
  lastName: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: CreatedTimestamp

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: UpdatedTimestamp
}

# A connection to a list of `User` values.
type UsersConnection {
  # A list of `User` objects.
  nodes: [User!]!

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User!
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  NATURAL
  ROW_ID_ASC
  ROW_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar UUID

